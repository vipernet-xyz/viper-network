// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vipernet.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	github_com_vipernet_xyz_viper_network_types "github.com/vipernet-xyz/viper-network/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SessionHeader defines the header for session information
type SessionHeader struct {
	ProviderPubKey     string `protobuf:"bytes,1,opt,name=providerPubKey,proto3" json:"provider_public_key"`
	Chain              string `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain"`
	GeoZone            string `protobuf:"bytes,3,opt,name=geoZone,proto3" json:"geo_zone"`
	NumServicers       int32  `protobuf:"varint,4,opt,name=numServicers,proto3" json:"num_servicers"`
	SessionBlockHeight int64  `protobuf:"varint,5,opt,name=sessionBlockHeight,proto3" json:"session_height"`
}

func (m *SessionHeader) Reset()      { *m = SessionHeader{} }
func (*SessionHeader) ProtoMessage() {}
func (*SessionHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{0}
}
func (m *SessionHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionHeader.Merge(m, src)
}
func (m *SessionHeader) XXX_Size() int {
	return m.Size()
}
func (m *SessionHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SessionHeader proto.InternalMessageInfo

type Session struct {
	SessionHeader    SessionHeader        `protobuf:"bytes,1,opt,name=sessionHeader,proto3" json:"header"`
	SessionKey       SessionKey           `protobuf:"bytes,2,opt,name=sessionKey,proto3,casttype=SessionKey" json:"key"`
	SessionServicers SessionServicers     `protobuf:"bytes,3,rep,name=sessionServicers,proto3" json:"servicers"`
	SessionFishermen SessionFishermen     `protobuf:"bytes,4,rep,name=sessionFishermen,proto3" json:"fishermen"`
}

func (m *Session) Reset()      { *m = Session{} }
func (*Session) ProtoMessage() {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{1}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

type MsgClaim struct {
	SessionHeader    SessionHeader                                       `protobuf:"bytes,1,opt,name=sessionHeader,proto3" json:"header"`
	MerkleRoot       HashRange                                           `protobuf:"bytes,2,opt,name=merkleRoot,proto3" json:"merkle_root"`
	TotalProofs      int64                                               `protobuf:"varint,3,opt,name=totalProofs,proto3" json:"total_proofs"`
	FromAddress      github_com_vipernet_xyz_viper_network_types.Address `protobuf:"bytes,4,opt,name=fromAddress,proto3,casttype=github.com/vipernet-xyz/viper-network/types.Address" json:"from_address"`
	EvidenceType     EvidenceType                                        `protobuf:"varint,5,opt,name=evidenceType,proto3,casttype=EvidenceType" json:"evidence_type"`
	ExpirationHeight int64                                               `protobuf:"varint,6,opt,name=expirationHeight,proto3" json:"expiration_height"`
}

func (m *MsgClaim) Reset()      { *m = MsgClaim{} }
func (*MsgClaim) ProtoMessage() {}
func (*MsgClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{2}
}
func (m *MsgClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaim.Merge(m, src)
}
func (m *MsgClaim) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaim.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaim proto.InternalMessageInfo

func (*MsgClaim) XXX_MessageName() string {
	return "x.vipernet.MsgClaim"
}

type MsgProtoProof struct {
	MerkleProof  MerkleProof  `protobuf:"bytes,1,opt,name=merkleProof,proto3" json:"merkle_proofs"`
	Leaf         ProofI       `protobuf:"bytes,2,opt,name=leaf,proto3" json:"leaf"`
	EvidenceType EvidenceType `protobuf:"varint,3,opt,name=evidenceType,proto3,casttype=EvidenceType" json:"evidence_type"`
}

func (m *MsgProtoProof) Reset()      { *m = MsgProtoProof{} }
func (*MsgProtoProof) ProtoMessage() {}
func (*MsgProtoProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{3}
}
func (m *MsgProtoProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProtoProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProtoProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProtoProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProtoProof.Merge(m, src)
}
func (m *MsgProtoProof) XXX_Size() int {
	return m.Size()
}
func (m *MsgProtoProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProtoProof.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProtoProof proto.InternalMessageInfo

func (*MsgProtoProof) XXX_MessageName() string {
	return "x.vipernet.MsgProtoProof"
}

type ProofI struct {
	// Types that are valid to be assigned to Proof:
	//	*ProofI_RelayProof
	//	*ProofI_ChallengeProof
	Proof isProofI_Proof `protobuf_oneof:"proof"`
}

func (m *ProofI) Reset()      { *m = ProofI{} }
func (*ProofI) ProtoMessage() {}
func (*ProofI) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{4}
}
func (m *ProofI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofI.Merge(m, src)
}
func (m *ProofI) XXX_Size() int {
	return m.Size()
}
func (m *ProofI) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofI.DiscardUnknown(m)
}

var xxx_messageInfo_ProofI proto.InternalMessageInfo

type isProofI_Proof interface {
	isProofI_Proof()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProofI_RelayProof struct {
	RelayProof *RelayProof `protobuf:"bytes,1,opt,name=relayProof,proto3,oneof" json:"relayProof,omitempty"`
}
type ProofI_ChallengeProof struct {
	ChallengeProof *ChallengeProofInvalidData `protobuf:"bytes,2,opt,name=challengeProof,proto3,oneof" json:"challengeProof,omitempty"`
}

func (*ProofI_RelayProof) isProofI_Proof()     {}
func (*ProofI_ChallengeProof) isProofI_Proof() {}

func (m *ProofI) GetProof() isProofI_Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *ProofI) GetRelayProof() *RelayProof {
	if x, ok := m.GetProof().(*ProofI_RelayProof); ok {
		return x.RelayProof
	}
	return nil
}

func (m *ProofI) GetChallengeProof() *ChallengeProofInvalidData {
	if x, ok := m.GetProof().(*ProofI_ChallengeProof); ok {
		return x.ChallengeProof
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProofI) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProofI_RelayProof)(nil),
		(*ProofI_ChallengeProof)(nil),
	}
}

type ProtoEvidence struct {
	BloomBytes    []byte         `protobuf:"bytes,1,opt,name=bloomBytes,proto3" json:"bloom_bytes"`
	SessionHeader *SessionHeader `protobuf:"bytes,2,opt,name=sessionHeader,proto3" json:"evidence_header"`
	NumOfProofs   int64          `protobuf:"varint,3,opt,name=numOfProofs,proto3" json:"num_of_proofs"`
	Proofs        ProofIs       `protobuf:"bytes,4,rep,name=proofs,proto3" json:"proofs"`
	EvidenceType  EvidenceType   `protobuf:"varint,5,opt,name=evidenceType,proto3,casttype=EvidenceType" json:"evidence_type"`
}

func (m *ProtoEvidence) Reset()      { *m = ProtoEvidence{} }
func (*ProtoEvidence) ProtoMessage() {}
func (*ProtoEvidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{5}
}
func (m *ProtoEvidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoEvidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoEvidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoEvidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoEvidence.Merge(m, src)
}
func (m *ProtoEvidence) XXX_Size() int {
	return m.Size()
}
func (m *ProtoEvidence) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoEvidence.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoEvidence proto.InternalMessageInfo

type RelayProof struct {
	RequestHash        string `protobuf:"bytes,1,opt,name=requestHash,proto3" json:"request_hash"`
	Entropy            int64  `protobuf:"varint,2,opt,name=entropy,proto3" json:"entropy"`
	SessionBlockHeight int64  `protobuf:"varint,3,opt,name=sessionBlockHeight,proto3" json:"session_block_height"`
	ServicerPubKey     string `protobuf:"bytes,4,opt,name=servicerPubKey,proto3" json:"servicer_pub_key"`
	Blockchain         string `protobuf:"bytes,5,opt,name=blockchain,proto3" json:"blockchain"`
	Token              AAT    `protobuf:"bytes,6,opt,name=token,proto3" json:"aat"`
	Signature          string `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature"`
	GeoZone            string `protobuf:"bytes,8,opt,name=geoZone,proto3" json:"geo_zone"`
	NumServicers       int32  `protobuf:"varint,9,opt,name=numServicers,proto3" json:"num_servicers"`
}

func (m *RelayProof) Reset()      { *m = RelayProof{} }
func (*RelayProof) ProtoMessage() {}
func (*RelayProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{6}
}
func (m *RelayProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayProof.Merge(m, src)
}
func (m *RelayProof) XXX_Size() int {
	return m.Size()
}
func (m *RelayProof) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayProof.DiscardUnknown(m)
}

var xxx_messageInfo_RelayProof proto.InternalMessageInfo

type ChallengeProofInvalidData struct {
	MajorityResponses []RelayResponse                                     `protobuf:"bytes,1,rep,name=majorityResponses,proto3" json:"majority_responses"`
	MinorityResponse  RelayResponse                                       `protobuf:"bytes,2,opt,name=minorityResponse,proto3" json:"minority_response"`
	ReporterAddress   github_com_vipernet_xyz_viper_network_types.Address `protobuf:"bytes,3,opt,name=reporterAddress,proto3,casttype=github.com/vipernet-xyz/viper-network/types.Address" json:"reporters_address"`
}

func (m *ChallengeProofInvalidData) Reset()      { *m = ChallengeProofInvalidData{} }
func (*ChallengeProofInvalidData) ProtoMessage() {}
func (*ChallengeProofInvalidData) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{7}
}
func (m *ChallengeProofInvalidData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeProofInvalidData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeProofInvalidData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeProofInvalidData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeProofInvalidData.Merge(m, src)
}
func (m *ChallengeProofInvalidData) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeProofInvalidData) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeProofInvalidData.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeProofInvalidData proto.InternalMessageInfo

type RelayResponse struct {
	Signature string     `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature"`
	Response  string     `protobuf:"bytes,2,opt,name=response,proto3" json:"payload"`
	Proof     RelayProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof"`
}

func (m *RelayResponse) Reset()      { *m = RelayResponse{} }
func (*RelayResponse) ProtoMessage() {}
func (*RelayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{8}
}
func (m *RelayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayResponse.Merge(m, src)
}
func (m *RelayResponse) XXX_Size() int {
	return m.Size()
}
func (m *RelayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RelayResponse proto.InternalMessageInfo

type AAT struct {
	Version           string `protobuf:"bytes,1,opt,name=version,proto3" json:"version"`
	ProviderPublicKey string `protobuf:"bytes,2,opt,name=providerPublicKey,proto3" json:"provider_pub_key"`
	ClientPublicKey   string `protobuf:"bytes,3,opt,name=clientPublicKey,proto3" json:"client_pub_key"`
	ProviderSignature string `protobuf:"bytes,4,opt,name=providerSignature,proto3" json:"signature"`
}

func (m *AAT) Reset()      { *m = AAT{} }
func (*AAT) ProtoMessage() {}
func (*AAT) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{9}
}
func (m *AAT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AAT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AAT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AAT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AAT.Merge(m, src)
}
func (m *AAT) XXX_Size() int {
	return m.Size()
}
func (m *AAT) XXX_DiscardUnknown() {
	xxx_messageInfo_AAT.DiscardUnknown(m)
}

var xxx_messageInfo_AAT proto.InternalMessageInfo

type MerkleProof struct {
	TargetIndex int64       `protobuf:"varint,1,opt,name=TargetIndex,proto3" json:"index"`
	HashRanges  []HashRange `protobuf:"bytes,2,rep,name=hashRanges,proto3" json:"hash_ranges"`
	Target      HashRange   `protobuf:"bytes,3,opt,name=target,proto3" json:"target_range"`
}

func (m *MerkleProof) Reset()      { *m = MerkleProof{} }
func (*MerkleProof) ProtoMessage() {}
func (*MerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{10}
}
func (m *MerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleProof.Merge(m, src)
}
func (m *MerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *MerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleProof proto.InternalMessageInfo

// Range for merkle sum index tree
type Range struct {
	Lower uint64 `protobuf:"varint,1,opt,name=lower,proto3" json:"lower"`
	Upper uint64 `protobuf:"varint,2,opt,name=upper,proto3" json:"upper"`
}

func (m *Range) Reset()      { *m = Range{} }
func (*Range) ProtoMessage() {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{11}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

type HashRange struct {
	Hash  []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"merkleHash"`
	Range Range  `protobuf:"bytes,2,opt,name=range,proto3" json:"range"`
}

func (m *HashRange) Reset()      { *m = HashRange{} }
func (*HashRange) ProtoMessage() {}
func (*HashRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{12}
}
func (m *HashRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashRange.Merge(m, src)
}
func (m *HashRange) XXX_Size() int {
	return m.Size()
}
func (m *HashRange) XXX_DiscardUnknown() {
	xxx_messageInfo_HashRange.DiscardUnknown(m)
}

var xxx_messageInfo_HashRange proto.InternalMessageInfo

func (m *HashRange) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *HashRange) GetRange() Range {
	if m != nil {
		return m.Range
	}
	return Range{}
}

type TestResult struct {
	ServicerAddress github_com_vipernet_xyz_viper_network_types.Address `protobuf:"bytes,1,opt,name=servicerAddress,proto3,casttype=github.com/vipernet-xyz/viper-network/types.Address" json:"servicer_address"`
	Timestamp       time.Time                                           `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Latency         time.Duration                                       `protobuf:"bytes,3,opt,name=latency,proto3,stdduration" json:"latency"`
	IsAvailable     bool                                                `protobuf:"varint,4,opt,name=isAvailable,proto3" json:"is_available"`
	IsReliable      bool                                                `protobuf:"varint,5,opt,name=isReliable,proto3" json:"is_reliable"`
}

func (m *TestResult) Reset()      { *m = TestResult{} }
func (*TestResult) ProtoMessage() {}
func (*TestResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{13}
}
func (m *TestResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestResult.Merge(m, src)
}
func (m *TestResult) XXX_Size() int {
	return m.Size()
}
func (m *TestResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TestResult.DiscardUnknown(m)
}

var xxx_messageInfo_TestResult proto.InternalMessageInfo

func (*TestResult) XXX_MessageName() string {
	return "x.vipernet.TestResult"
}

type TestI struct {
	// Types that are valid to be assigned to Test:
	//
	//	*TestI_TestResult
	Test isTestI_Test `protobuf_oneof:"test"`
}

func (m *TestI) Reset()      { *m = TestI{} }
func (*TestI) ProtoMessage() {}
func (*TestI) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{14}
}
func (m *TestI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestI.Merge(m, src)
}
func (m *TestI) XXX_Size() int {
	return m.Size()
}
func (m *TestI) XXX_DiscardUnknown() {
	xxx_messageInfo_TestI.DiscardUnknown(m)
}

var xxx_messageInfo_TestI proto.InternalMessageInfo

type isTestI_Test interface {
	isTestI_Test()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TestI_TestResult struct {
	TestResult *TestResult `protobuf:"bytes,1,opt,name=testResult,proto3,oneof" json:"testResult,omitempty"`
}

func (*TestI_TestResult) isTestI_Test() {}

func (m *TestI) GetTest() isTestI_Test {
	if m != nil {
		return m.Test
	}
	return nil
}

func (m *TestI) GetTestResult() *TestResult {
	if x, ok := m.GetTest().(*TestI_TestResult); ok {
		return x.TestResult
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TestI) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TestI_TestResult)(nil),
	}
}

type ProtoResult struct {
	SessionHeader    *SessionHeader                                      `protobuf:"bytes,1,opt,name=sessionHeader,proto3" json:"evidence_header"`
	ServicerAddr     github_com_vipernet_xyz_viper_network_types.Address `protobuf:"bytes,2,opt,name=servicerAddr,proto3,casttype=github.com/vipernet-xyz/viper-network/types.Address" json:"servicer_addr"`
	NumOfTestResults int64                                               `protobuf:"varint,3,opt,name=numOfTestResults,proto3" json:"num_of_test_results"`
	TestResults      TestIs                                            `protobuf:"bytes,4,rep,name=testResults,proto3" json:"test_results"`
	EvidenceType     EvidenceType                                        `protobuf:"varint,5,opt,name=evidenceType,proto3,casttype=EvidenceType" json:"evidence_type"`
}

func (m *ProtoResult) Reset()      { *m = ProtoResult{} }
func (*ProtoResult) ProtoMessage() {}
func (*ProtoResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{15}
}
func (m *ProtoResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoResult.Merge(m, src)
}
func (m *ProtoResult) XXX_Size() int {
	return m.Size()
}
func (m *ProtoResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoResult.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoResult proto.InternalMessageInfo

type ViperQoSReport struct {
	FirstSampleTimestamp time.Time                                          `protobuf:"bytes,1,opt,name=FirstSampleTimestamp,proto3,stdtime" json:"first_sample_timestamp"`
	BlockHeight          int64                                              `protobuf:"varint,2,opt,name=BlockHeight,proto3" json:"block_height"`
	LatencyScore         github_com_vipernet_xyz_viper_network_types.BigDec `protobuf:"bytes,3,opt,name=LatencyScore,proto3,customtype=github.com/vipernet-xyz/viper-network/types.BigDec" json:"latency_score"`
	AvailabilityScore    github_com_vipernet_xyz_viper_network_types.BigDec `protobuf:"bytes,4,opt,name=AvailabilityScore,proto3,customtype=github.com/vipernet-xyz/viper-network/types.BigDec" json:"availability_score"`
	ReliabilityScore     github_com_vipernet_xyz_viper_network_types.BigDec `protobuf:"bytes,5,opt,name=ReliabilityScore,proto3,customtype=github.com/vipernet-xyz/viper-network/types.BigDec" json:"reliability_score"`
	SampleRoot           HashRange                                          `protobuf:"bytes,6,opt,name=SampleRoot,proto3" json:"sample_root"`
	Nonce                int64                                              `protobuf:"varint,7,opt,name=Nonce,proto3" json:"nonce"`
	Signature            string                                             `protobuf:"bytes,8,opt,name=Signature,proto3" json:"signature"`
}

func (m *ViperQoSReport) Reset()      { *m = ViperQoSReport{} }
func (*ViperQoSReport) ProtoMessage() {}
func (*ViperQoSReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa955d7377574a13, []int{16}
}
func (m *ViperQoSReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViperQoSReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViperQoSReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViperQoSReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViperQoSReport.Merge(m, src)
}
func (m *ViperQoSReport) XXX_Size() int {
	return m.Size()
}
func (m *ViperQoSReport) XXX_DiscardUnknown() {
	xxx_messageInfo_ViperQoSReport.DiscardUnknown(m)
}

var xxx_messageInfo_ViperQoSReport proto.InternalMessageInfo

func (*ViperQoSReport) XXX_MessageName() string {
	return "x.vipernet.ViperQoSReport"
}
func init() {
	proto.RegisterType((*SessionHeader)(nil), "x.vipernet.SessionHeader")
	proto.RegisterType((*Session)(nil), "x.vipernet.Session")
	proto.RegisterType((*MsgClaim)(nil), "x.vipernet.MsgClaim")
	proto.RegisterType((*MsgProtoProof)(nil), "x.vipernet.MsgProtoProof")
	proto.RegisterType((*ProofI)(nil), "x.vipernet.ProofI")
	proto.RegisterType((*ProtoEvidence)(nil), "x.vipernet.ProtoEvidence")
	proto.RegisterType((*RelayProof)(nil), "x.vipernet.RelayProof")
	proto.RegisterType((*ChallengeProofInvalidData)(nil), "x.vipernet.ChallengeProofInvalidData")
	proto.RegisterType((*RelayResponse)(nil), "x.vipernet.RelayResponse")
	proto.RegisterType((*AAT)(nil), "x.vipernet.AAT")
	proto.RegisterType((*MerkleProof)(nil), "x.vipernet.MerkleProof")
	proto.RegisterType((*Range)(nil), "x.vipernet.Range")
	proto.RegisterType((*HashRange)(nil), "x.vipernet.HashRange")
	proto.RegisterType((*TestResult)(nil), "x.vipernet.TestResult")
	proto.RegisterType((*TestI)(nil), "x.vipernet.TestI")
	proto.RegisterType((*ProtoResult)(nil), "x.vipernet.ProtoResult")
	proto.RegisterType((*ViperQoSReport)(nil), "x.vipernet.ViperQoSReport")
}

func init() { proto.RegisterFile("vipernet.proto", fileDescriptor_fa955d7377574a13) }

var fileDescriptor_fa955d7377574a13 = []byte{
	// 1904 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x8a, 0x1f, 0x92, 0x1e, 0x49, 0x49, 0x1c, 0xcb, 0x31, 0xad, 0x03, 0xd7, 0x15, 0x90,
	0xd6, 0x40, 0x10, 0x0a, 0x90, 0x9b, 0xa0, 0x48, 0x02, 0x14, 0x5a, 0xdb, 0xa9, 0x5c, 0xc7, 0x95,
	0x3a, 0x12, 0x8a, 0x22, 0x97, 0xed, 0x92, 0x1a, 0x91, 0x5b, 0x2d, 0x77, 0xd8, 0xd9, 0xa5, 0x22,
	0xa6, 0x40, 0xd1, 0x63, 0x2e, 0x05, 0x72, 0x2c, 0x7a, 0x2a, 0x72, 0x0a, 0x7c, 0x2f, 0xd0, 0x3f,
	0xc1, 0xe8, 0xc9, 0xbd, 0x05, 0x39, 0xac, 0x62, 0x19, 0x05, 0x02, 0x9e, 0xd2, 0xab, 0x4f, 0xc1,
	0x7c, 0xed, 0xce, 0x92, 0x74, 0x6c, 0x47, 0xbe, 0x70, 0x77, 0xdf, 0xfb, 0xbd, 0xf7, 0x66, 0xde,
	0x9b, 0xf7, 0x31, 0x84, 0x95, 0x53, 0x7f, 0x48, 0x58, 0x48, 0xe2, 0xf6, 0x90, 0xd1, 0x98, 0x22,
	0x38, 0x6b, 0x6b, 0xca, 0xc6, 0x7a, 0x8f, 0xf6, 0xa8, 0x20, 0x6f, 0xf1, 0x37, 0x89, 0xd8, 0xb0,
	0x7b, 0x94, 0xf6, 0x02, 0xb2, 0x25, 0xbe, 0x3a, 0xa3, 0xe3, 0xad, 0xd8, 0x1f, 0x90, 0x28, 0xf6,
	0x06, 0x43, 0x05, 0x68, 0x4d, 0x03, 0x8e, 0x46, 0xcc, 0x8b, 0x7d, 0x1a, 0x4a, 0xfe, 0xe6, 0x3f,
	0x16, 0xa0, 0x7e, 0x40, 0xa2, 0xc8, 0xa7, 0xe1, 0x2e, 0xf1, 0x8e, 0x08, 0x43, 0xbf, 0x84, 0x95,
	0x21, 0xa3, 0xa7, 0xfe, 0x11, 0x61, 0xfb, 0xa3, 0xce, 0x7d, 0x32, 0x6e, 0x5a, 0x37, 0xac, 0x9b,
	0xcb, 0xce, 0xb5, 0x49, 0x62, 0x5f, 0xd1, 0x1c, 0x77, 0x38, 0xea, 0x04, 0x7e, 0xd7, 0x3d, 0x21,
	0x63, 0x3c, 0x05, 0x47, 0x36, 0x94, 0xbb, 0x7d, 0xcf, 0x0f, 0x9b, 0x0b, 0x42, 0x6e, 0x79, 0x92,
	0xd8, 0x92, 0x80, 0xe5, 0x03, 0xfd, 0x14, 0x16, 0x7b, 0x84, 0x7e, 0x4c, 0x43, 0xd2, 0x2c, 0x0a,
	0x48, 0x6d, 0x92, 0xd8, 0x4b, 0x3d, 0x42, 0xdd, 0x4f, 0x69, 0x48, 0xb0, 0x66, 0xa2, 0x77, 0xa0,
	0x16, 0x8e, 0x06, 0x07, 0x84, 0x9d, 0xfa, 0x5d, 0xc2, 0xa2, 0x66, 0xe9, 0x86, 0x75, 0xb3, 0xec,
	0x34, 0x26, 0x89, 0x5d, 0x0f, 0x47, 0x03, 0x37, 0xd2, 0x0c, 0x9c, 0x83, 0x21, 0x07, 0x50, 0x24,
	0x77, 0xe4, 0x04, 0xb4, 0x7b, 0xb2, 0x4b, 0xfc, 0x5e, 0x3f, 0x6e, 0x96, 0x6f, 0x58, 0x37, 0x8b,
	0x0e, 0x9a, 0x24, 0xf6, 0x8a, 0xe2, 0xba, 0x7d, 0xc1, 0xc1, 0x73, 0xd0, 0xef, 0x95, 0x3e, 0xfb,
	0xa7, 0x5d, 0xd8, 0xfc, 0xd7, 0x02, 0x2c, 0x2a, 0xe7, 0xa0, 0x3d, 0xa8, 0x47, 0xa6, 0x9f, 0x84,
	0x57, 0xaa, 0xdb, 0xd7, 0xdb, 0x59, 0x8c, 0xda, 0x39, 0x47, 0x3a, 0x2b, 0x8f, 0x12, 0xbb, 0x30,
	0x49, 0xec, 0x4a, 0x5f, 0x7c, 0xe3, 0xbc, 0x3c, 0x7a, 0x07, 0x40, 0x11, 0xb8, 0x8f, 0xb9, 0xaf,
	0x6a, 0xce, 0xd5, 0x49, 0x62, 0x17, 0x4f, 0xc8, 0xf8, 0x59, 0x62, 0xc3, 0x41, 0xca, 0xc4, 0x06,
	0x10, 0x3d, 0x80, 0x35, 0xf5, 0x95, 0x39, 0xa6, 0x78, 0xa3, 0x78, 0xb3, 0xe6, 0xfc, 0x64, 0x92,
	0xd8, 0xcb, 0xa9, 0x53, 0x1e, 0x9e, 0xdb, 0x6b, 0x07, 0x53, 0x40, 0x3c, 0x23, 0x6a, 0xa8, 0xfb,
	0xd0, 0x8f, 0xfa, 0x84, 0x0d, 0x48, 0xd8, 0x2c, 0x65, 0xea, 0x8e, 0x35, 0xd1, 0x50, 0x97, 0x02,
	0xf1, 0x8c, 0xa8, 0xf2, 0xdb, 0xd7, 0x45, 0x58, 0x7a, 0x10, 0xf5, 0x6e, 0x07, 0x9e, 0x3f, 0x78,
	0xfd, 0x8e, 0xfb, 0x35, 0xc0, 0x80, 0xb0, 0x93, 0x80, 0x60, 0x4a, 0x63, 0xe1, 0xb8, 0xea, 0xf6,
	0x55, 0x53, 0xdb, 0xae, 0x17, 0xf5, 0xb1, 0x17, 0xf6, 0x88, 0x73, 0x45, 0x69, 0xaa, 0x4a, 0x01,
	0x97, 0x51, 0x1a, 0x63, 0x43, 0x1a, 0x6d, 0x43, 0x35, 0xa6, 0xb1, 0x17, 0xec, 0x33, 0x4a, 0x8f,
	0x23, 0x71, 0x1c, 0x8b, 0xce, 0xda, 0x24, 0xb1, 0x6b, 0x82, 0xec, 0x0e, 0x05, 0x1d, 0x9b, 0x20,
	0xe4, 0x43, 0xf5, 0x98, 0xd1, 0xc1, 0xce, 0xd1, 0x11, 0x23, 0x91, 0x3c, 0x95, 0x35, 0xe7, 0x57,
	0x5c, 0x86, 0x93, 0x5d, 0x4f, 0xd2, 0x9f, 0x25, 0xf6, 0xad, 0x9e, 0x1f, 0xf7, 0x47, 0x9d, 0x76,
	0x97, 0x0e, 0xb6, 0xf4, 0xe2, 0xde, 0x3e, 0x1b, 0x7f, 0x2a, 0x3f, 0xde, 0x0e, 0x49, 0xfc, 0x09,
	0x65, 0x27, 0x5b, 0xf1, 0x78, 0x48, 0xa2, 0xb6, 0x52, 0x87, 0x4d, 0xdd, 0xe8, 0x2e, 0xd4, 0x08,
	0x4f, 0xad, 0xb0, 0x4b, 0x0e, 0xc7, 0x43, 0x22, 0x0e, 0x71, 0x59, 0x44, 0xa6, 0xae, 0xe9, 0x2e,
	0x17, 0x7f, 0x96, 0xd8, 0xb5, 0xbb, 0x06, 0x10, 0xe7, 0xc4, 0xd0, 0x0e, 0xac, 0x91, 0xb3, 0xa1,
	0x2f, 0x13, 0x5f, 0xe5, 0x43, 0x45, 0x6c, 0x95, 0x1f, 0xb8, 0x46, 0xc6, 0xd3, 0x29, 0x31, 0x03,
	0x7f, 0x6f, 0x89, 0x07, 0xf6, 0xb3, 0x2f, 0x6c, 0x6b, 0xf3, 0x5b, 0x0b, 0xea, 0x0f, 0xa2, 0xde,
	0x3e, 0x2f, 0x1f, 0xc2, 0x23, 0x68, 0x1f, 0x94, 0x7f, 0xc5, 0xa7, 0x8a, 0xef, 0x35, 0x33, 0x22,
	0x0f, 0x32, 0xb6, 0x73, 0x55, 0xc5, 0xa4, 0xae, 0x62, 0xa2, 0x5d, 0x6c, 0xa8, 0x40, 0x3f, 0x87,
	0x52, 0x40, 0xbc, 0x63, 0x15, 0x5c, 0x64, 0xaa, 0x12, 0x80, 0x7b, 0x4e, 0x4d, 0x69, 0x11, 0x38,
	0x2c, 0x7e, 0x67, 0xbc, 0x55, 0xfc, 0x51, 0xde, 0x32, 0xb6, 0xfa, 0x85, 0x05, 0x15, 0x69, 0x0f,
	0xfd, 0x02, 0x80, 0x91, 0xc0, 0x1b, 0x9b, 0x5b, 0x7c, 0xc3, 0x5c, 0x17, 0x4e, 0xb9, 0xbb, 0x05,
	0x6c, 0x60, 0xd1, 0x1e, 0xac, 0x74, 0xfb, 0x5e, 0x10, 0x90, 0xb0, 0xa7, 0x1c, 0x24, 0x77, 0xf5,
	0xa6, 0x29, 0x7d, 0x3b, 0x87, 0xb8, 0x17, 0x9e, 0x7a, 0x81, 0x7f, 0x74, 0xc7, 0x8b, 0xbd, 0xdd,
	0x02, 0x9e, 0x12, 0x97, 0x39, 0xe6, 0x2c, 0x42, 0x59, 0x78, 0x6e, 0xf3, 0x7c, 0x01, 0xea, 0x22,
	0x18, 0x7a, 0x4b, 0x68, 0x0b, 0xa0, 0x13, 0x50, 0x3a, 0x70, 0xc6, 0x31, 0x89, 0xc4, 0x5a, 0x6b,
	0xce, 0x2a, 0xcf, 0x02, 0x41, 0x75, 0x3b, 0x9c, 0x8c, 0x0d, 0x08, 0x3a, 0x9c, 0x4e, 0xd1, 0x85,
	0x17, 0xa5, 0xe8, 0x95, 0x49, 0x62, 0xaf, 0xa6, 0x4e, 0x9d, 0x9f, 0xa7, 0xb7, 0xa0, 0x1a, 0x8e,
	0x06, 0x7b, 0xc7, 0xb9, 0xdc, 0x4a, 0xab, 0x37, 0x3d, 0x4e, 0x23, 0x6f, 0xa0, 0xd0, 0x5d, 0xa8,
	0x48, 0xb2, 0xa8, 0x42, 0xf3, 0x63, 0x7f, 0x5d, 0xd7, 0x07, 0x89, 0x7c, 0x78, 0x6e, 0x2f, 0x4a,
	0x4e, 0x84, 0x15, 0xe9, 0x35, 0x25, 0x8e, 0x2a, 0x67, 0xff, 0x2b, 0x02, 0x64, 0xe1, 0xe5, 0x35,
	0x83, 0x91, 0x3f, 0x8d, 0x48, 0x14, 0xf3, 0x42, 0xa3, 0xba, 0xa3, 0xa8, 0x19, 0x8a, 0xec, 0xf6,
	0x79, 0x01, 0x32, 0x41, 0xe8, 0x4d, 0x58, 0x24, 0x61, 0xcc, 0xe8, 0x50, 0x56, 0xfa, 0xa2, 0x53,
	0x9d, 0x24, 0xb6, 0x26, 0x61, 0xfd, 0x82, 0x76, 0xe7, 0xb6, 0x2e, 0xe9, 0xb9, 0xe6, 0x24, 0xb1,
	0xd7, 0x75, 0xeb, 0xea, 0x70, 0xf6, 0x0f, 0x34, 0x30, 0xf4, 0x01, 0xac, 0xe8, 0x56, 0xa0, 0xba,
	0x78, 0x49, 0xac, 0x73, 0x7d, 0x92, 0xd8, 0x6b, 0x9a, 0xc3, 0xbb, 0xb8, 0x6c, 0xe1, 0x79, 0x2c,
	0x6a, 0x8b, 0x13, 0xd4, 0x3d, 0x91, 0x7d, 0xbc, 0x2c, 0x24, 0x57, 0x26, 0x89, 0x6d, 0x50, 0xb1,
	0xf1, 0x8e, 0xb6, 0xa1, 0x1c, 0xd3, 0x13, 0x12, 0x8a, 0xaa, 0x52, 0xdd, 0x5e, 0x35, 0x83, 0xb6,
	0xb3, 0x73, 0xe8, 0x54, 0x55, 0xc4, 0x8a, 0x9e, 0x17, 0x63, 0x09, 0x45, 0x6f, 0xc1, 0x72, 0xe4,
	0xf7, 0x42, 0x2f, 0x1e, 0x31, 0xd2, 0x5c, 0x14, 0x26, 0xea, 0xa2, 0x83, 0x69, 0x22, 0xce, 0x5e,
	0xcd, 0x91, 0x61, 0xe9, 0x55, 0x46, 0x86, 0xe5, 0x97, 0x1a, 0x19, 0x54, 0x9c, 0xbf, 0x59, 0x80,
	0xeb, 0xcf, 0x4d, 0x44, 0xd4, 0x85, 0xc6, 0xc0, 0xfb, 0x23, 0x65, 0x7e, 0x3c, 0xc6, 0x24, 0x1a,
	0xd2, 0x30, 0x12, 0xc9, 0x55, 0x9c, 0x4e, 0x14, 0x71, 0x52, 0x34, 0xc2, 0xd9, 0x50, 0x3b, 0x47,
	0x5a, 0xd6, 0x65, 0x5a, 0x18, 0xcf, 0xea, 0x43, 0x7f, 0x80, 0xb5, 0x81, 0x1f, 0xe6, 0x88, 0xf3,
	0x92, 0x31, 0x6f, 0x43, 0xe7, 0x43, 0x43, 0x8b, 0xa6, 0x36, 0xf0, 0x8c, 0x36, 0x74, 0x0a, 0xab,
	0x8c, 0x0c, 0x29, 0x8b, 0x09, 0xd3, 0x1d, 0xac, 0x28, 0x2a, 0xc4, 0x47, 0x5c, 0x83, 0x66, 0x45,
	0x97, 0x6d, 0x63, 0xd3, 0x46, 0x94, 0x8b, 0xbf, 0xb4, 0xa0, 0x9e, 0x5b, 0x7c, 0xfe, 0x18, 0x58,
	0x2f, 0x38, 0x06, 0x3f, 0x83, 0x25, 0x66, 0xba, 0x65, 0x59, 0xe6, 0xd1, 0xd0, 0x1b, 0x07, 0xd4,
	0x3b, 0xc2, 0x29, 0x13, 0xbd, 0xaf, 0xaa, 0xa3, 0xd8, 0xdb, 0x73, 0x2b, 0xb5, 0x53, 0x57, 0x9e,
	0x93, 0x60, 0x2c, 0x1f, 0x6a, 0xa9, 0xff, 0xb7, 0xa0, 0xb8, 0xb3, 0x73, 0xc8, 0x53, 0xf7, 0x94,
	0x30, 0x9e, 0x5f, 0x6a, 0x79, 0xc2, 0xa4, 0x22, 0x61, 0xfd, 0x82, 0x1c, 0x68, 0x18, 0x73, 0x70,
	0xe0, 0x77, 0xf5, 0x54, 0xa7, 0x72, 0xce, 0x9c, 0x9c, 0x45, 0xce, 0xcd, 0xc2, 0xd1, 0x07, 0xb0,
	0xda, 0x0d, 0x7c, 0x12, 0xc6, 0x99, 0x06, 0x39, 0x20, 0x8b, 0xb1, 0x55, 0xb2, 0x52, 0xf9, 0x69,
	0x28, 0x7a, 0x3f, 0x5b, 0xc1, 0x41, 0xea, 0xd1, 0xd2, 0x3c, 0x8f, 0xce, 0xe2, 0xd4, 0x9e, 0xff,
	0x6b, 0x41, 0xd5, 0xe8, 0xd5, 0xe8, 0x2d, 0xa8, 0x1e, 0x7a, 0xac, 0x47, 0xe2, 0x7b, 0xe1, 0x11,
	0x39, 0x13, 0xfb, 0x2f, 0xca, 0x81, 0xde, 0xe7, 0x04, 0x6c, 0x72, 0xf9, 0x5c, 0xd6, 0xd7, 0x93,
	0x57, 0xd4, 0x5c, 0x10, 0x99, 0xf1, 0xa2, 0xb9, 0x8c, 0x0b, 0xb8, 0x4c, 0x48, 0x60, 0x43, 0x1a,
	0xdd, 0x86, 0x4a, 0x2c, 0x54, 0xab, 0x00, 0x3e, 0x47, 0xcf, 0xba, 0xd2, 0x53, 0x93, 0x60, 0xa9,
	0x09, 0x2b, 0x51, 0xb5, 0xa7, 0x3d, 0x28, 0x0b, 0x30, 0xbf, 0x97, 0x04, 0xf4, 0x13, 0x35, 0x80,
	0x96, 0xe4, 0x36, 0x04, 0x01, 0xcb, 0x07, 0x07, 0x8c, 0x86, 0x43, 0xd5, 0xfe, 0x14, 0x40, 0x10,
	0xb0, 0x7c, 0x28, 0x85, 0x3d, 0x58, 0x4e, 0x57, 0x80, 0x36, 0xa1, 0xd4, 0xd7, 0x5d, 0xa0, 0x26,
	0x6b, 0xa4, 0x1c, 0x64, 0x04, 0x44, 0xf0, 0xd0, 0xbb, 0x50, 0x16, 0x0b, 0x53, 0x99, 0xdc, 0xc8,
	0x1d, 0x46, 0xb1, 0x8f, 0xf4, 0x1c, 0xca, 0x0d, 0xc8, 0xc7, 0xe6, 0xdf, 0x8a, 0x00, 0x87, 0x24,
	0x8a, 0x31, 0x89, 0x46, 0x41, 0x8c, 0x46, 0xb0, 0xaa, 0xeb, 0x97, 0xce, 0x5c, 0x69, 0xf5, 0x7e,
	0xae, 0xa6, 0x5f, 0x36, 0x71, 0xa7, 0x6c, 0xa0, 0x3d, 0x58, 0x4e, 0x2f, 0x95, 0x6a, 0x07, 0x1b,
	0x6d, 0x79, 0xab, 0x6c, 0xeb, 0x5b, 0x65, 0xfb, 0x50, 0x23, 0xd2, 0xf1, 0x2e, 0x13, 0xfa, 0xfc,
	0xdc, 0xb6, 0x70, 0xf6, 0x89, 0x76, 0x61, 0x31, 0xf0, 0x62, 0x12, 0x76, 0xc7, 0x2a, 0xb8, 0xd7,
	0x67, 0xd4, 0xdd, 0x51, 0x97, 0xd4, 0xf4, 0xa0, 0x68, 0x89, 0xbf, 0x73, 0x5d, 0xfa, 0x83, 0x77,
	0x62, 0x3f, 0xda, 0x39, 0xf5, 0xfc, 0xc0, 0xeb, 0x04, 0xf2, 0xac, 0x2f, 0xc9, 0x4e, 0xec, 0x47,
	0xae, 0xa7, 0xe9, 0xd8, 0x04, 0xf1, 0xe1, 0xc8, 0x8f, 0x30, 0x09, 0x7c, 0x21, 0x52, 0x16, 0x22,
	0x62, 0x38, 0xf2, 0x23, 0x97, 0x29, 0x32, 0x36, 0x20, 0xc6, 0x38, 0xb8, 0x07, 0x65, 0x1e, 0x0e,
	0x31, 0x0c, 0xc6, 0x69, 0x5c, 0xe6, 0x0d, 0x83, 0x59, 0xd4, 0xf8, 0x30, 0x98, 0x61, 0xd5, 0xec,
	0x56, 0x81, 0x12, 0xa7, 0x6d, 0xfe, 0xbb, 0x08, 0x55, 0x31, 0xba, 0xa9, 0x08, 0xff, 0xfe, 0x95,
	0xaf, 0x4a, 0xd7, 0x1e, 0x25, 0xb6, 0xf5, 0x12, 0xb3, 0x58, 0x00, 0x35, 0x33, 0xae, 0xea, 0xba,
	0xb9, 0xcb, 0xfb, 0x62, 0xee, 0xe0, 0xfc, 0xd8, 0x53, 0x93, 0xd3, 0x8e, 0x6e, 0xc3, 0x9a, 0x98,
	0xe9, 0x32, 0x37, 0xe8, 0xf1, 0x4f, 0xfc, 0x89, 0xa0, 0xc6, 0x3f, 0xee, 0x02, 0xde, 0xa9, 0x38,
	0x1b, 0xcf, 0x08, 0xa0, 0x3d, 0xa8, 0xc6, 0x86, 0xbc, 0x1c, 0x07, 0x1b, 0xd3, 0x5e, 0xbe, 0xe7,
	0x6c, 0x88, 0xfc, 0x37, 0x74, 0x3d, 0x3c, 0xb7, 0x2b, 0x82, 0xc5, 0xef, 0x6d, 0x86, 0xc2, 0xd7,
	0x3a, 0x13, 0xfe, 0xa7, 0x0c, 0x2b, 0xbf, 0xe3, 0x0b, 0xf9, 0x2d, 0x3d, 0xc0, 0xa2, 0xd5, 0x21,
	0x06, 0xeb, 0x1f, 0xfa, 0x2c, 0x8a, 0x0f, 0xbc, 0xc1, 0x30, 0x20, 0x69, 0x46, 0xa8, 0x20, 0xfe,
	0x50, 0xce, 0x6c, 0xaa, 0x53, 0xfe, 0xc6, 0x31, 0x97, 0x77, 0x23, 0xa1, 0xc0, 0xcd, 0x27, 0xd0,
	0x5c, 0xdd, 0x3c, 0x03, 0xcc, 0x49, 0x71, 0x21, 0xbb, 0xbf, 0xe6, 0x26, 0x44, 0x13, 0x84, 0x28,
	0xd4, 0x3e, 0x92, 0x09, 0x74, 0xd0, 0xa5, 0x8c, 0xa8, 0xf6, 0x7f, 0x9f, 0xaf, 0xe1, 0xeb, 0xc4,
	0xde, 0x7e, 0x95, 0xf0, 0x3b, 0x7e, 0xef, 0x0e, 0xe9, 0x72, 0x0f, 0xaa, 0x94, 0x74, 0x23, 0xae,
	0x12, 0xe7, 0x0c, 0xa0, 0xbf, 0x40, 0x43, 0xe5, 0x9f, 0x1f, 0xf8, 0xb1, 0xb2, 0x2a, 0xaf, 0xcd,
	0xfb, 0x97, 0xb2, 0x8a, 0x3c, 0x43, 0xad, 0x32, 0x3d, 0x6b, 0x0a, 0xfd, 0x19, 0xd6, 0x64, 0x36,
	0x1b, 0xe6, 0xcb, 0xc2, 0xfc, 0xde, 0xa5, 0xcc, 0x37, 0x58, 0xa6, 0x55, 0x59, 0x9f, 0x31, 0xc4,
	0xbb, 0xa2, 0x0c, 0x9a, 0xf8, 0xb7, 0xa2, 0xf2, 0x52, 0xff, 0x56, 0xa8, 0x03, 0x20, 0xff, 0xad,
	0xc8, 0xa4, 0x79, 0x83, 0xfa, 0x0d, 0x0d, 0xbb, 0x72, 0x5c, 0x56, 0x8d, 0x38, 0xe4, 0x04, 0x2c,
	0xe9, 0x7c, 0x98, 0xca, 0x5a, 0xff, 0xd2, 0xdc, 0x61, 0x2a, 0x6b, 0xf9, 0x69, 0x61, 0x73, 0x82,
	0xc7, 0x4f, 0x5a, 0x85, 0xaf, 0x9e, 0xb4, 0x0a, 0xdf, 0x3d, 0x69, 0x59, 0x7f, 0xbd, 0x68, 0x59,
	0x5f, 0x5e, 0xb4, 0xac, 0x47, 0x17, 0x2d, 0xeb, 0xf1, 0x45, 0xcb, 0xfa, 0xe6, 0xa2, 0x65, 0x7d,
	0x7b, 0xd1, 0x2a, 0x7c, 0x77, 0xd1, 0xb2, 0x3e, 0x7f, 0xda, 0x2a, 0x3c, 0x7e, 0xda, 0x2a, 0x7c,
	0xf5, 0xb4, 0x55, 0xf8, 0xf8, 0xdd, 0x97, 0x73, 0xda, 0x59, 0xca, 0x94, 0xfe, 0xeb, 0x54, 0x44,
	0x06, 0xdc, 0xfa, 0x3e, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x53, 0xe9, 0x7a, 0xee, 0x14, 0x00, 0x00,
}

func (this *SessionHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SessionHeader)
	if !ok {
		that2, ok := that.(SessionHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProviderPubKey != that1.ProviderPubKey {
		return false
	}
	if this.Chain != that1.Chain {
		return false
	}
	if this.GeoZone != that1.GeoZone {
		return false
	}
	if this.NumServicers != that1.NumServicers {
		return false
	}
	if this.SessionBlockHeight != that1.SessionBlockHeight {
		return false
	}
	return true
}
func (this *Session) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Session)
	if !ok {
		that2, ok := that.(Session)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SessionHeader.Equal(&that1.SessionHeader) {
		return false
	}
	if !bytes.Equal(this.SessionKey, that1.SessionKey) {
		return false
	}
	if len(this.SessionServicers) != len(that1.SessionServicers) {
		return false
	}
	for i := range this.SessionServicers {
		if !bytes.Equal(this.SessionServicers[i], that1.SessionServicers[i]) {
			return false
		}
	}
	if len(this.SessionFishermen) != len(that1.SessionFishermen) {
		return false
	}
	for i := range this.SessionFishermen {
		if !bytes.Equal(this.SessionFishermen[i], that1.SessionFishermen[i]) {
			return false
		}
	}
	return true
}
func (this *MsgClaim) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgClaim)
	if !ok {
		that2, ok := that.(MsgClaim)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SessionHeader.Equal(&that1.SessionHeader) {
		return false
	}
	if !this.MerkleRoot.Equal(that1.MerkleRoot) {
		return false
	}
	if this.TotalProofs != that1.TotalProofs {
		return false
	}
	if !bytes.Equal(this.FromAddress, that1.FromAddress) {
		return false
	}
	if this.EvidenceType != that1.EvidenceType {
		return false
	}
	if this.ExpirationHeight != that1.ExpirationHeight {
		return false
	}
	return true
}
func (this *MsgProtoProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgProtoProof)
	if !ok {
		that2, ok := that.(MsgProtoProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MerkleProof.Equal(&that1.MerkleProof) {
		return false
	}
	if !this.Leaf.Equal(&that1.Leaf) {
		return false
	}
	if this.EvidenceType != that1.EvidenceType {
		return false
	}
	return true
}
func (this *ProofI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProofI)
	if !ok {
		that2, ok := that.(ProofI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Proof == nil {
		if this.Proof != nil {
			return false
		}
	} else if this.Proof == nil {
		return false
	} else if !this.Proof.Equal(that1.Proof) {
		return false
	}
	return true
}
func (this *ProofI_RelayProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProofI_RelayProof)
	if !ok {
		that2, ok := that.(ProofI_RelayProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RelayProof.Equal(that1.RelayProof) {
		return false
	}
	return true
}
func (this *ProofI_ChallengeProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProofI_ChallengeProof)
	if !ok {
		that2, ok := that.(ProofI_ChallengeProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ChallengeProof.Equal(that1.ChallengeProof) {
		return false
	}
	return true
}
func (this *ProtoEvidence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoEvidence)
	if !ok {
		that2, ok := that.(ProtoEvidence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.BloomBytes, that1.BloomBytes) {
		return false
	}
	if !this.SessionHeader.Equal(that1.SessionHeader) {
		return false
	}
	if this.NumOfProofs != that1.NumOfProofs {
		return false
	}
	if len(this.Proofs) != len(that1.Proofs) {
		return false
	}
	for i := range this.Proofs {
		if !this.Proofs[i].Equal(&that1.Proofs[i]) {
			return false
		}
	}
	if this.EvidenceType != that1.EvidenceType {
		return false
	}
	return true
}
func (this *RelayProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RelayProof)
	if !ok {
		that2, ok := that.(RelayProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestHash != that1.RequestHash {
		return false
	}
	if this.Entropy != that1.Entropy {
		return false
	}
	if this.SessionBlockHeight != that1.SessionBlockHeight {
		return false
	}
	if this.ServicerPubKey != that1.ServicerPubKey {
		return false
	}
	if this.Blockchain != that1.Blockchain {
		return false
	}
	if !this.Token.Equal(&that1.Token) {
		return false
	}
	if this.Signature != that1.Signature {
		return false
	}
	if this.GeoZone != that1.GeoZone {
		return false
	}
	if this.NumServicers != that1.NumServicers {
		return false
	}
	return true
}
func (this *ChallengeProofInvalidData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeProofInvalidData)
	if !ok {
		that2, ok := that.(ChallengeProofInvalidData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.MajorityResponses) != len(that1.MajorityResponses) {
		return false
	}
	for i := range this.MajorityResponses {
		if !this.MajorityResponses[i].Equal(&that1.MajorityResponses[i]) {
			return false
		}
	}
	if !this.MinorityResponse.Equal(&that1.MinorityResponse) {
		return false
	}
	if !bytes.Equal(this.ReporterAddress, that1.ReporterAddress) {
		return false
	}
	return true
}
func (this *RelayResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RelayResponse)
	if !ok {
		that2, ok := that.(RelayResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Signature != that1.Signature {
		return false
	}
	if this.Response != that1.Response {
		return false
	}
	if !this.Proof.Equal(&that1.Proof) {
		return false
	}
	return true
}
func (this *AAT) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AAT)
	if !ok {
		that2, ok := that.(AAT)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ProviderPublicKey != that1.ProviderPublicKey {
		return false
	}
	if this.ClientPublicKey != that1.ClientPublicKey {
		return false
	}
	if this.ProviderSignature != that1.ProviderSignature {
		return false
	}
	return true
}
func (this *MerkleProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MerkleProof)
	if !ok {
		that2, ok := that.(MerkleProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TargetIndex != that1.TargetIndex {
		return false
	}
	if len(this.HashRanges) != len(that1.HashRanges) {
		return false
	}
	for i := range this.HashRanges {
		if !this.HashRanges[i].Equal(that1.HashRanges[i]) {
			return false
		}
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	return true
}
func (this *TestResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TestResult)
	if !ok {
		that2, ok := that.(TestResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.ServicerAddress, that1.ServicerAddress) {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.Latency != that1.Latency {
		return false
	}
	if this.IsAvailable != that1.IsAvailable {
		return false
	}
	if this.IsReliable != that1.IsReliable {
		return false
	}
	return true
}
func (this *TestI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TestI)
	if !ok {
		that2, ok := that.(TestI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Test == nil {
		if this.Test != nil {
			return false
		}
	} else if this.Test == nil {
		return false
	} else if !this.Test.Equal(that1.Test) {
		return false
	}
	return true
}
func (this *TestI_TestResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TestI_TestResult)
	if !ok {
		that2, ok := that.(TestI_TestResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TestResult.Equal(that1.TestResult) {
		return false
	}
	return true
}
func (this *ProtoResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoResult)
	if !ok {
		that2, ok := that.(ProtoResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SessionHeader.Equal(that1.SessionHeader) {
		return false
	}
	if !bytes.Equal(this.ServicerAddr, that1.ServicerAddr) {
		return false
	}
	if this.NumOfTestResults != that1.NumOfTestResults {
		return false
	}
	if len(this.TestResults) != len(that1.TestResults) {
		return false
	}
	for i := range this.TestResults {
		if !this.TestResults[i].Equal(that1.TestResults[i]) {
			return false
		}
	}
	if this.EvidenceType != that1.EvidenceType {
		return false
	}
	return true
}
func (this *ViperQoSReport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ViperQoSReport)
	if !ok {
		that2, ok := that.(ViperQoSReport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FirstSampleTimestamp.Equal(that1.FirstSampleTimestamp) {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	if !this.LatencyScore.Equal(that1.LatencyScore) {
		return false
	}
	if !this.AvailabilityScore.Equal(that1.AvailabilityScore) {
		return false
	}
	if !this.ReliabilityScore.Equal(that1.ReliabilityScore) {
		return false
	}
	if !this.SampleRoot.Equal(that1.SampleRoot) {
		return false
	}
	if this.Nonce != that1.Nonce {
		return false
	}
	if this.Signature != that1.Signature {
		return false
	}
	return true
}
func (this *SessionHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.SessionHeader{")
	s = append(s, "ProviderPubKey: "+fmt.Sprintf("%#v", this.ProviderPubKey)+",\n")
	s = append(s, "Chain: "+fmt.Sprintf("%#v", this.Chain)+",\n")
	s = append(s, "GeoZone: "+fmt.Sprintf("%#v", this.GeoZone)+",\n")
	s = append(s, "NumServicers: "+fmt.Sprintf("%#v", this.NumServicers)+",\n")
	s = append(s, "SessionBlockHeight: "+fmt.Sprintf("%#v", this.SessionBlockHeight)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Session) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.Session{")
	s = append(s, "SessionHeader: "+strings.Replace(this.SessionHeader.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "SessionKey: "+fmt.Sprintf("%#v", this.SessionKey)+",\n")
	s = append(s, "SessionServicers: "+fmt.Sprintf("%#v", this.SessionServicers)+",\n")
	s = append(s, "SessionFishermen: "+fmt.Sprintf("%#v", this.SessionFishermen)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgClaim) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&types.MsgClaim{")
	s = append(s, "SessionHeader: "+strings.Replace(this.SessionHeader.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "MerkleRoot: "+strings.Replace(this.MerkleRoot.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "TotalProofs: "+fmt.Sprintf("%#v", this.TotalProofs)+",\n")
	s = append(s, "FromAddress: "+fmt.Sprintf("%#v", this.FromAddress)+",\n")
	s = append(s, "EvidenceType: "+fmt.Sprintf("%#v", this.EvidenceType)+",\n")
	s = append(s, "ExpirationHeight: "+fmt.Sprintf("%#v", this.ExpirationHeight)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgProtoProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.MsgProtoProof{")
	s = append(s, "MerkleProof: "+strings.Replace(this.MerkleProof.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Leaf: "+strings.Replace(this.Leaf.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "EvidenceType: "+fmt.Sprintf("%#v", this.EvidenceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProofI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.ProofI{")
	if this.Proof != nil {
		s = append(s, "Proof: "+fmt.Sprintf("%#v", this.Proof)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProofI_RelayProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.ProofI_RelayProof{` +
		`RelayProof:` + fmt.Sprintf("%#v", this.RelayProof) + `}`}, ", ")
	return s
}
func (this *ProofI_ChallengeProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.ProofI_ChallengeProof{` +
		`ChallengeProof:` + fmt.Sprintf("%#v", this.ChallengeProof) + `}`}, ", ")
	return s
}
func (this *ProtoEvidence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.ProtoEvidence{")
	s = append(s, "BloomBytes: "+fmt.Sprintf("%#v", this.BloomBytes)+",\n")
	if this.SessionHeader != nil {
		s = append(s, "SessionHeader: "+fmt.Sprintf("%#v", this.SessionHeader)+",\n")
	}
	s = append(s, "NumOfProofs: "+fmt.Sprintf("%#v", this.NumOfProofs)+",\n")
	if this.Proofs != nil {
		vs := make([]ProofI, len(this.Proofs))
		for i := range vs {
			vs[i] = this.Proofs[i]
		}
		s = append(s, "Proofs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "EvidenceType: "+fmt.Sprintf("%#v", this.EvidenceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RelayProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&types.RelayProof{")
	s = append(s, "RequestHash: "+fmt.Sprintf("%#v", this.RequestHash)+",\n")
	s = append(s, "Entropy: "+fmt.Sprintf("%#v", this.Entropy)+",\n")
	s = append(s, "SessionBlockHeight: "+fmt.Sprintf("%#v", this.SessionBlockHeight)+",\n")
	s = append(s, "ServicerPubKey: "+fmt.Sprintf("%#v", this.ServicerPubKey)+",\n")
	s = append(s, "Blockchain: "+fmt.Sprintf("%#v", this.Blockchain)+",\n")
	s = append(s, "Token: "+strings.Replace(this.Token.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	s = append(s, "GeoZone: "+fmt.Sprintf("%#v", this.GeoZone)+",\n")
	s = append(s, "NumServicers: "+fmt.Sprintf("%#v", this.NumServicers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChallengeProofInvalidData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.ChallengeProofInvalidData{")
	if this.MajorityResponses != nil {
		vs := make([]RelayResponse, len(this.MajorityResponses))
		for i := range vs {
			vs[i] = this.MajorityResponses[i]
		}
		s = append(s, "MajorityResponses: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "MinorityResponse: "+strings.Replace(this.MinorityResponse.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "ReporterAddress: "+fmt.Sprintf("%#v", this.ReporterAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RelayResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.RelayResponse{")
	s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	s = append(s, "Response: "+fmt.Sprintf("%#v", this.Response)+",\n")
	s = append(s, "Proof: "+strings.Replace(this.Proof.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AAT) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.AAT{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "ProviderPublicKey: "+fmt.Sprintf("%#v", this.ProviderPublicKey)+",\n")
	s = append(s, "ClientPublicKey: "+fmt.Sprintf("%#v", this.ClientPublicKey)+",\n")
	s = append(s, "ProviderSignature: "+fmt.Sprintf("%#v", this.ProviderSignature)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MerkleProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.MerkleProof{")
	s = append(s, "TargetIndex: "+fmt.Sprintf("%#v", this.TargetIndex)+",\n")
	if this.HashRanges != nil {
		vs := make([]HashRange, len(this.HashRanges))
		for i := range vs {
			vs[i] = this.HashRanges[i]
		}
		s = append(s, "HashRanges: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "Target: "+strings.Replace(this.Target.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Range) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.Range{")
	s = append(s, "Lower: "+fmt.Sprintf("%#v", this.Lower)+",\n")
	s = append(s, "Upper: "+fmt.Sprintf("%#v", this.Upper)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HashRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.HashRange{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "Range: "+strings.Replace(this.Range.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TestResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.TestResult{")
	s = append(s, "ServicerAddress: "+fmt.Sprintf("%#v", this.ServicerAddress)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Latency: "+fmt.Sprintf("%#v", this.Latency)+",\n")
	s = append(s, "IsAvailable: "+fmt.Sprintf("%#v", this.IsAvailable)+",\n")
	s = append(s, "IsReliable: "+fmt.Sprintf("%#v", this.IsReliable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TestI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.TestI{")
	if this.Test != nil {
		s = append(s, "Test: "+fmt.Sprintf("%#v", this.Test)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TestI_TestResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.TestI_TestResult{` +
		`TestResult:` + fmt.Sprintf("%#v", this.TestResult) + `}`}, ", ")
	return s
}
func (this *ProtoResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&types.ProtoResult{")
	if this.SessionHeader != nil {
		s = append(s, "SessionHeader: "+fmt.Sprintf("%#v", this.SessionHeader)+",\n")
	}
	s = append(s, "ServicerAddr: "+fmt.Sprintf("%#v", this.ServicerAddr)+",\n")
	s = append(s, "NumOfTestResults: "+fmt.Sprintf("%#v", this.NumOfTestResults)+",\n")
	if this.TestResults != nil {
		s = append(s, "TestResults: "+fmt.Sprintf("%#v", this.TestResults)+",\n")
	}
	s = append(s, "EvidenceType: "+fmt.Sprintf("%#v", this.EvidenceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ViperQoSReport) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&types.ViperQoSReport{")
	s = append(s, "FirstSampleTimestamp: "+fmt.Sprintf("%#v", this.FirstSampleTimestamp)+",\n")
	s = append(s, "BlockHeight: "+fmt.Sprintf("%#v", this.BlockHeight)+",\n")
	s = append(s, "LatencyScore: "+fmt.Sprintf("%#v", this.LatencyScore)+",\n")
	s = append(s, "AvailabilityScore: "+fmt.Sprintf("%#v", this.AvailabilityScore)+",\n")
	s = append(s, "ReliabilityScore: "+fmt.Sprintf("%#v", this.ReliabilityScore)+",\n")
	s = append(s, "SampleRoot: "+strings.Replace(this.SampleRoot.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringVipernet(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SessionHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionBlockHeight != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.SessionBlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.NumServicers != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.NumServicers))
		i--
		dAtA[i] = 0x20
	}
	if len(m.GeoZone) > 0 {
		i -= len(m.GeoZone)
		copy(dAtA[i:], m.GeoZone)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.GeoZone)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProviderPubKey) > 0 {
		i -= len(m.ProviderPubKey)
		copy(dAtA[i:], m.ProviderPubKey)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.ProviderPubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SessionFishermen) > 0 {
		for iNdEx := len(m.SessionFishermen) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SessionFishermen[iNdEx])
			copy(dAtA[i:], m.SessionFishermen[iNdEx])
			i = encodeVarintVipernet(dAtA, i, uint64(len(m.SessionFishermen[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SessionServicers) > 0 {
		for iNdEx := len(m.SessionServicers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SessionServicers[iNdEx])
			copy(dAtA[i:], m.SessionServicers[iNdEx])
			i = encodeVarintVipernet(dAtA, i, uint64(len(m.SessionServicers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SessionKey) > 0 {
		i -= len(m.SessionKey)
		copy(dAtA[i:], m.SessionKey)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.SessionKey)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.SessionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpirationHeight != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.ExpirationHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.EvidenceType != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.EvidenceType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.TotalProofs != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.TotalProofs))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.MerkleRoot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.SessionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgProtoProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProtoProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProtoProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EvidenceType != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.EvidenceType))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Leaf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.MerkleProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProofI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size := m.Proof.Size()
			i -= size
			if _, err := m.Proof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProofI_RelayProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofI_RelayProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RelayProof != nil {
		{
			size, err := m.RelayProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVipernet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ProofI_ChallengeProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofI_ChallengeProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ChallengeProof != nil {
		{
			size, err := m.ChallengeProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVipernet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProtoEvidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoEvidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoEvidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EvidenceType != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.EvidenceType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Proofs) > 0 {
		for iNdEx := len(m.Proofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Proofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVipernet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumOfProofs != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.NumOfProofs))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionHeader != nil {
		{
			size, err := m.SessionHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVipernet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.BloomBytes) > 0 {
		i -= len(m.BloomBytes)
		copy(dAtA[i:], m.BloomBytes)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.BloomBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelayProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumServicers != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.NumServicers))
		i--
		dAtA[i] = 0x48
	}
	if len(m.GeoZone) > 0 {
		i -= len(m.GeoZone)
		copy(dAtA[i:], m.GeoZone)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.GeoZone)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Blockchain) > 0 {
		i -= len(m.Blockchain)
		copy(dAtA[i:], m.Blockchain)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.Blockchain)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServicerPubKey) > 0 {
		i -= len(m.ServicerPubKey)
		copy(dAtA[i:], m.ServicerPubKey)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.ServicerPubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.SessionBlockHeight != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.SessionBlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.Entropy != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.Entropy))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RequestHash) > 0 {
		i -= len(m.RequestHash)
		copy(dAtA[i:], m.RequestHash)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.RequestHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeProofInvalidData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeProofInvalidData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeProofInvalidData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReporterAddress) > 0 {
		i -= len(m.ReporterAddress)
		copy(dAtA[i:], m.ReporterAddress)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.ReporterAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.MinorityResponse.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MajorityResponses) > 0 {
		for iNdEx := len(m.MajorityResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MajorityResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVipernet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RelayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Response) > 0 {
		i -= len(m.Response)
		copy(dAtA[i:], m.Response)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.Response)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AAT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AAT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AAT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProviderSignature) > 0 {
		i -= len(m.ProviderSignature)
		copy(dAtA[i:], m.ProviderSignature)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.ProviderSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClientPublicKey) > 0 {
		i -= len(m.ClientPublicKey)
		copy(dAtA[i:], m.ClientPublicKey)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.ClientPublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProviderPublicKey) > 0 {
		i -= len(m.ProviderPublicKey)
		copy(dAtA[i:], m.ProviderPublicKey)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.ProviderPublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.HashRanges) > 0 {
		for iNdEx := len(m.HashRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HashRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVipernet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TargetIndex != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.TargetIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Upper != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.Upper))
		i--
		dAtA[i] = 0x10
	}
	if m.Lower != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.Lower))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HashRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsReliable {
		i--
		if m.IsReliable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IsAvailable {
		i--
		if m.IsAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	n14, err14 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Latency, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Latency):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintVipernet(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x1a
	n15, err15 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err15 != nil {
		return 0, err15
	}
	i -= n15
	i = encodeVarintVipernet(dAtA, i, uint64(n15))
	i--
	dAtA[i] = 0x12
	if len(m.ServicerAddress) > 0 {
		i -= len(m.ServicerAddress)
		copy(dAtA[i:], m.ServicerAddress)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.ServicerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Test != nil {
		{
			size := m.Test.Size()
			i -= size
			if _, err := m.Test.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TestI_TestResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestI_TestResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestResult != nil {
		{
			size, err := m.TestResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVipernet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ProtoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EvidenceType != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.EvidenceType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TestResults) > 0 {
		for iNdEx := len(m.TestResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TestResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVipernet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumOfTestResults != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.NumOfTestResults))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServicerAddr) > 0 {
		i -= len(m.ServicerAddr)
		copy(dAtA[i:], m.ServicerAddr)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.ServicerAddr)))
		i--
		dAtA[i] = 0x12
	}
	if m.SessionHeader != nil {
		{
			size, err := m.SessionHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVipernet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViperQoSReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViperQoSReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViperQoSReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintVipernet(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x42
	}
	if m.Nonce != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.SampleRoot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.ReliabilityScore.Size()
		i -= size
		if _, err := m.ReliabilityScore.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.AvailabilityScore.Size()
		i -= size
		if _, err := m.AvailabilityScore.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.LatencyScore.Size()
		i -= size
		if _, err := m.LatencyScore.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVipernet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BlockHeight != 0 {
		i = encodeVarintVipernet(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	n19, err19 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.FirstSampleTimestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.FirstSampleTimestamp):])
	if err19 != nil {
		return 0, err19
	}
	i -= n19
	i = encodeVarintVipernet(dAtA, i, uint64(n19))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintVipernet(dAtA []byte, offset int, v uint64) int {
	offset -= sovVipernet(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SessionHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderPubKey)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.GeoZone)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	if m.NumServicers != 0 {
		n += 1 + sovVipernet(uint64(m.NumServicers))
	}
	if m.SessionBlockHeight != 0 {
		n += 1 + sovVipernet(uint64(m.SessionBlockHeight))
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionHeader.Size()
	n += 1 + l + sovVipernet(uint64(l))
	l = len(m.SessionKey)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	if len(m.SessionServicers) > 0 {
		for _, b := range m.SessionServicers {
			l = len(b)
			n += 1 + l + sovVipernet(uint64(l))
		}
	}
	if len(m.SessionFishermen) > 0 {
		for _, b := range m.SessionFishermen {
			l = len(b)
			n += 1 + l + sovVipernet(uint64(l))
		}
	}
	return n
}

func (m *MsgClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionHeader.Size()
	n += 1 + l + sovVipernet(uint64(l))
	l = m.MerkleRoot.Size()
	n += 1 + l + sovVipernet(uint64(l))
	if m.TotalProofs != 0 {
		n += 1 + sovVipernet(uint64(m.TotalProofs))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	if m.EvidenceType != 0 {
		n += 1 + sovVipernet(uint64(m.EvidenceType))
	}
	if m.ExpirationHeight != 0 {
		n += 1 + sovVipernet(uint64(m.ExpirationHeight))
	}
	return n
}

func (m *MsgProtoProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MerkleProof.Size()
	n += 1 + l + sovVipernet(uint64(l))
	l = m.Leaf.Size()
	n += 1 + l + sovVipernet(uint64(l))
	if m.EvidenceType != 0 {
		n += 1 + sovVipernet(uint64(m.EvidenceType))
	}
	return n
}

func (m *ProofI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		n += m.Proof.Size()
	}
	return n
}

func (m *ProofI_RelayProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelayProof != nil {
		l = m.RelayProof.Size()
		n += 1 + l + sovVipernet(uint64(l))
	}
	return n
}
func (m *ProofI_ChallengeProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChallengeProof != nil {
		l = m.ChallengeProof.Size()
		n += 1 + l + sovVipernet(uint64(l))
	}
	return n
}
func (m *ProtoEvidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BloomBytes)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	if m.SessionHeader != nil {
		l = m.SessionHeader.Size()
		n += 1 + l + sovVipernet(uint64(l))
	}
	if m.NumOfProofs != 0 {
		n += 1 + sovVipernet(uint64(m.NumOfProofs))
	}
	if len(m.Proofs) > 0 {
		for _, e := range m.Proofs {
			l = e.Size()
			n += 1 + l + sovVipernet(uint64(l))
		}
	}
	if m.EvidenceType != 0 {
		n += 1 + sovVipernet(uint64(m.EvidenceType))
	}
	return n
}

func (m *RelayProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestHash)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	if m.Entropy != 0 {
		n += 1 + sovVipernet(uint64(m.Entropy))
	}
	if m.SessionBlockHeight != 0 {
		n += 1 + sovVipernet(uint64(m.SessionBlockHeight))
	}
	l = len(m.ServicerPubKey)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.Blockchain)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = m.Token.Size()
	n += 1 + l + sovVipernet(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.GeoZone)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	if m.NumServicers != 0 {
		n += 1 + sovVipernet(uint64(m.NumServicers))
	}
	return n
}

func (m *ChallengeProofInvalidData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MajorityResponses) > 0 {
		for _, e := range m.MajorityResponses {
			l = e.Size()
			n += 1 + l + sovVipernet(uint64(l))
		}
	}
	l = m.MinorityResponse.Size()
	n += 1 + l + sovVipernet(uint64(l))
	l = len(m.ReporterAddress)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	return n
}

func (m *RelayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.Response)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = m.Proof.Size()
	n += 1 + l + sovVipernet(uint64(l))
	return n
}

func (m *AAT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.ProviderPublicKey)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.ClientPublicKey)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.ProviderSignature)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	return n
}

func (m *MerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetIndex != 0 {
		n += 1 + sovVipernet(uint64(m.TargetIndex))
	}
	if len(m.HashRanges) > 0 {
		for _, e := range m.HashRanges {
			l = e.Size()
			n += 1 + l + sovVipernet(uint64(l))
		}
	}
	l = m.Target.Size()
	n += 1 + l + sovVipernet(uint64(l))
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lower != 0 {
		n += 1 + sovVipernet(uint64(m.Lower))
	}
	if m.Upper != 0 {
		n += 1 + sovVipernet(uint64(m.Upper))
	}
	return n
}

func (m *HashRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = m.Range.Size()
	n += 1 + l + sovVipernet(uint64(l))
	return n
}

func (m *TestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServicerAddress)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovVipernet(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Latency)
	n += 1 + l + sovVipernet(uint64(l))
	if m.IsAvailable {
		n += 2
	}
	if m.IsReliable {
		n += 2
	}
	return n
}

func (m *TestI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Test != nil {
		n += m.Test.Size()
	}
	return n
}

func (m *TestI_TestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovVipernet(uint64(l))
	}
	return n
}
func (m *ProtoResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionHeader != nil {
		l = m.SessionHeader.Size()
		n += 1 + l + sovVipernet(uint64(l))
	}
	l = len(m.ServicerAddr)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	if m.NumOfTestResults != 0 {
		n += 1 + sovVipernet(uint64(m.NumOfTestResults))
	}
	if len(m.TestResults) > 0 {
		for _, e := range m.TestResults {
			l = e.Size()
			n += 1 + l + sovVipernet(uint64(l))
		}
	}
	if m.EvidenceType != 0 {
		n += 1 + sovVipernet(uint64(m.EvidenceType))
	}
	return n
}

func (m *ViperQoSReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.FirstSampleTimestamp)
	n += 1 + l + sovVipernet(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovVipernet(uint64(m.BlockHeight))
	}
	l = m.LatencyScore.Size()
	n += 1 + l + sovVipernet(uint64(l))
	l = m.AvailabilityScore.Size()
	n += 1 + l + sovVipernet(uint64(l))
	l = m.ReliabilityScore.Size()
	n += 1 + l + sovVipernet(uint64(l))
	l = m.SampleRoot.Size()
	n += 1 + l + sovVipernet(uint64(l))
	if m.Nonce != 0 {
		n += 1 + sovVipernet(uint64(m.Nonce))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovVipernet(uint64(l))
	}
	return n
}

func sovVipernet(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVipernet(x uint64) (n int) {
	return sovVipernet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SessionHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SessionHeader{`,
		`ProviderPubKey:` + fmt.Sprintf("%v", this.ProviderPubKey) + `,`,
		`Chain:` + fmt.Sprintf("%v", this.Chain) + `,`,
		`GeoZone:` + fmt.Sprintf("%v", this.GeoZone) + `,`,
		`NumServicers:` + fmt.Sprintf("%v", this.NumServicers) + `,`,
		`SessionBlockHeight:` + fmt.Sprintf("%v", this.SessionBlockHeight) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Session) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Session{`,
		`SessionHeader:` + strings.Replace(strings.Replace(this.SessionHeader.String(), "SessionHeader", "SessionHeader", 1), `&`, ``, 1) + `,`,
		`SessionKey:` + fmt.Sprintf("%v", this.SessionKey) + `,`,
		`SessionServicers:` + fmt.Sprintf("%v", this.SessionServicers) + `,`,
		`SessionFishermen:` + fmt.Sprintf("%v", this.SessionFishermen) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MsgClaim) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MsgClaim{`,
		`SessionHeader:` + strings.Replace(strings.Replace(this.SessionHeader.String(), "SessionHeader", "SessionHeader", 1), `&`, ``, 1) + `,`,
		`MerkleRoot:` + strings.Replace(strings.Replace(this.MerkleRoot.String(), "HashRange", "HashRange", 1), `&`, ``, 1) + `,`,
		`TotalProofs:` + fmt.Sprintf("%v", this.TotalProofs) + `,`,
		`FromAddress:` + fmt.Sprintf("%v", this.FromAddress) + `,`,
		`EvidenceType:` + fmt.Sprintf("%v", this.EvidenceType) + `,`,
		`ExpirationHeight:` + fmt.Sprintf("%v", this.ExpirationHeight) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MsgProtoProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MsgProtoProof{`,
		`MerkleProof:` + strings.Replace(strings.Replace(this.MerkleProof.String(), "MerkleProof", "MerkleProof", 1), `&`, ``, 1) + `,`,
		`Leaf:` + strings.Replace(strings.Replace(this.Leaf.String(), "ProofI", "ProofI", 1), `&`, ``, 1) + `,`,
		`EvidenceType:` + fmt.Sprintf("%v", this.EvidenceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProofI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProofI{`,
		`Proof:` + fmt.Sprintf("%v", this.Proof) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProofI_RelayProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProofI_RelayProof{`,
		`RelayProof:` + strings.Replace(fmt.Sprintf("%v", this.RelayProof), "RelayProof", "RelayProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProofI_ChallengeProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProofI_ChallengeProof{`,
		`ChallengeProof:` + strings.Replace(fmt.Sprintf("%v", this.ChallengeProof), "ChallengeProofInvalidData", "ChallengeProofInvalidData", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoEvidence) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProofs := "[]ProofI{"
	for _, f := range this.Proofs {
		repeatedStringForProofs += strings.Replace(strings.Replace(f.String(), "ProofI", "ProofI", 1), `&`, ``, 1) + ","
	}
	repeatedStringForProofs += "}"
	s := strings.Join([]string{`&ProtoEvidence{`,
		`BloomBytes:` + fmt.Sprintf("%v", this.BloomBytes) + `,`,
		`SessionHeader:` + strings.Replace(this.SessionHeader.String(), "SessionHeader", "SessionHeader", 1) + `,`,
		`NumOfProofs:` + fmt.Sprintf("%v", this.NumOfProofs) + `,`,
		`Proofs:` + repeatedStringForProofs + `,`,
		`EvidenceType:` + fmt.Sprintf("%v", this.EvidenceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RelayProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RelayProof{`,
		`RequestHash:` + fmt.Sprintf("%v", this.RequestHash) + `,`,
		`Entropy:` + fmt.Sprintf("%v", this.Entropy) + `,`,
		`SessionBlockHeight:` + fmt.Sprintf("%v", this.SessionBlockHeight) + `,`,
		`ServicerPubKey:` + fmt.Sprintf("%v", this.ServicerPubKey) + `,`,
		`Blockchain:` + fmt.Sprintf("%v", this.Blockchain) + `,`,
		`Token:` + strings.Replace(strings.Replace(this.Token.String(), "AAT", "AAT", 1), `&`, ``, 1) + `,`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`GeoZone:` + fmt.Sprintf("%v", this.GeoZone) + `,`,
		`NumServicers:` + fmt.Sprintf("%v", this.NumServicers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeProofInvalidData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMajorityResponses := "[]RelayResponse{"
	for _, f := range this.MajorityResponses {
		repeatedStringForMajorityResponses += strings.Replace(strings.Replace(f.String(), "RelayResponse", "RelayResponse", 1), `&`, ``, 1) + ","
	}
	repeatedStringForMajorityResponses += "}"
	s := strings.Join([]string{`&ChallengeProofInvalidData{`,
		`MajorityResponses:` + repeatedStringForMajorityResponses + `,`,
		`MinorityResponse:` + strings.Replace(strings.Replace(this.MinorityResponse.String(), "RelayResponse", "RelayResponse", 1), `&`, ``, 1) + `,`,
		`ReporterAddress:` + fmt.Sprintf("%v", this.ReporterAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RelayResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RelayResponse{`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`Response:` + fmt.Sprintf("%v", this.Response) + `,`,
		`Proof:` + strings.Replace(strings.Replace(this.Proof.String(), "RelayProof", "RelayProof", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AAT) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AAT{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`ProviderPublicKey:` + fmt.Sprintf("%v", this.ProviderPublicKey) + `,`,
		`ClientPublicKey:` + fmt.Sprintf("%v", this.ClientPublicKey) + `,`,
		`ProviderSignature:` + fmt.Sprintf("%v", this.ProviderSignature) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MerkleProof) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHashRanges := "[]HashRange{"
	for _, f := range this.HashRanges {
		repeatedStringForHashRanges += strings.Replace(strings.Replace(f.String(), "HashRange", "HashRange", 1), `&`, ``, 1) + ","
	}
	repeatedStringForHashRanges += "}"
	s := strings.Join([]string{`&MerkleProof{`,
		`TargetIndex:` + fmt.Sprintf("%v", this.TargetIndex) + `,`,
		`HashRanges:` + repeatedStringForHashRanges + `,`,
		`Target:` + strings.Replace(strings.Replace(this.Target.String(), "HashRange", "HashRange", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Range) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Range{`,
		`Lower:` + fmt.Sprintf("%v", this.Lower) + `,`,
		`Upper:` + fmt.Sprintf("%v", this.Upper) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashRange{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`Range:` + strings.Replace(strings.Replace(this.Range.String(), "Range", "Range", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestResult{`,
		`ServicerAddress:` + fmt.Sprintf("%v", this.ServicerAddress) + `,`,
		`Timestamp:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Timestamp), "Timestamp", "timestamppb.Timestamp", 1), `&`, ``, 1) + `,`,
		`Latency:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Latency), "Duration", "durationpb.Duration", 1), `&`, ``, 1) + `,`,
		`IsAvailable:` + fmt.Sprintf("%v", this.IsAvailable) + `,`,
		`IsReliable:` + fmt.Sprintf("%v", this.IsReliable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestI{`,
		`Test:` + fmt.Sprintf("%v", this.Test) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestI_TestResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestI_TestResult{`,
		`TestResult:` + strings.Replace(fmt.Sprintf("%v", this.TestResult), "TestResult", "TestResult", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoResult) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTestResults := "[]*TestI{"
	for _, f := range this.TestResults {
		repeatedStringForTestResults += strings.Replace(f.String(), "TestI", "TestI", 1) + ","
	}
	repeatedStringForTestResults += "}"
	s := strings.Join([]string{`&ProtoResult{`,
		`SessionHeader:` + strings.Replace(this.SessionHeader.String(), "SessionHeader", "SessionHeader", 1) + `,`,
		`ServicerAddr:` + fmt.Sprintf("%v", this.ServicerAddr) + `,`,
		`NumOfTestResults:` + fmt.Sprintf("%v", this.NumOfTestResults) + `,`,
		`TestResults:` + repeatedStringForTestResults + `,`,
		`EvidenceType:` + fmt.Sprintf("%v", this.EvidenceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ViperQoSReport) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ViperQoSReport{`,
		`FirstSampleTimestamp:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.FirstSampleTimestamp), "Timestamp", "timestamppb.Timestamp", 1), `&`, ``, 1) + `,`,
		`BlockHeight:` + fmt.Sprintf("%v", this.BlockHeight) + `,`,
		`LatencyScore:` + fmt.Sprintf("%v", this.LatencyScore) + `,`,
		`AvailabilityScore:` + fmt.Sprintf("%v", this.AvailabilityScore) + `,`,
		`ReliabilityScore:` + fmt.Sprintf("%v", this.ReliabilityScore) + `,`,
		`SampleRoot:` + strings.Replace(strings.Replace(this.SampleRoot.String(), "HashRange", "HashRange", 1), `&`, ``, 1) + `,`,
		`Nonce:` + fmt.Sprintf("%v", this.Nonce) + `,`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringVipernet(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SessionHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeoZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumServicers", wireType)
			}
			m.NumServicers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumServicers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionBlockHeight", wireType)
			}
			m.SessionBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionKey = append(m.SessionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionKey == nil {
				m.SessionKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionServicers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionServicers = append(m.SessionServicers, make([]byte, postIndex-iNdEx))
			copy(m.SessionServicers[len(m.SessionServicers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionFishermen", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionFishermen = append(m.SessionFishermen, make([]byte, postIndex-iNdEx))
			copy(m.SessionFishermen[len(m.SessionFishermen)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerkleRoot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalProofs", wireType)
			}
			m.TotalProofs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalProofs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = append(m.FromAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.FromAddress == nil {
				m.FromAddress = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceType", wireType)
			}
			m.EvidenceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvidenceType |= EvidenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationHeight", wireType)
			}
			m.ExpirationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProtoProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProtoProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProtoProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerkleProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Leaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceType", wireType)
			}
			m.EvidenceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvidenceType |= EvidenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RelayProof{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Proof = &ProofI_RelayProof{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChallengeProofInvalidData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Proof = &ProofI_ChallengeProof{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoEvidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoEvidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoEvidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BloomBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BloomBytes = append(m.BloomBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.BloomBytes == nil {
				m.BloomBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionHeader == nil {
				m.SessionHeader = &SessionHeader{}
			}
			if err := m.SessionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfProofs", wireType)
			}
			m.NumOfProofs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfProofs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proofs = append(m.Proofs, ProofI{})
			if err := m.Proofs[len(m.Proofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceType", wireType)
			}
			m.EvidenceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvidenceType |= EvidenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelayProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entropy", wireType)
			}
			m.Entropy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Entropy |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionBlockHeight", wireType)
			}
			m.SessionBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicerPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicerPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blockchain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blockchain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeoZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumServicers", wireType)
			}
			m.NumServicers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumServicers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeProofInvalidData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeProofInvalidData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeProofInvalidData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorityResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MajorityResponses = append(m.MajorityResponses, RelayResponse{})
			if err := m.MajorityResponses[len(m.MajorityResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorityResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinorityResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReporterAddress = append(m.ReporterAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ReporterAddress == nil {
				m.ReporterAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AAT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AAT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AAT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIndex", wireType)
			}
			m.TargetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashRanges = append(m.HashRanges, HashRange{})
			if err := m.HashRanges[len(m.HashRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicerAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicerAddress = append(m.ServicerAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ServicerAddress == nil {
				m.ServicerAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Latency, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAvailable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReliable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Test = &TestI_TestResult{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionHeader == nil {
				m.SessionHeader = &SessionHeader{}
			}
			if err := m.SessionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicerAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicerAddr = append(m.ServicerAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.ServicerAddr == nil {
				m.ServicerAddr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfTestResults", wireType)
			}
			m.NumOfTestResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfTestResults |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestResults = append(m.TestResults, TestI{})
			if err := m.TestResults[len(m.TestResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceType", wireType)
			}
			m.EvidenceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvidenceType |= EvidenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViperQoSReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViperQoSReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViperQoSReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSampleTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.FirstSampleTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyScore", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatencyScore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityScore", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvailabilityScore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliabilityScore", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReliabilityScore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SampleRoot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVipernet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVipernet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVipernet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVipernet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVipernet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVipernet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVipernet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVipernet
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVipernet
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVipernet
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVipernet        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVipernet          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVipernet = fmt.Errorf("proto: unexpected end of group")
)
